"use client";

import React, { useState, useEffect, useRef, useMemo } from "react";
import { CircleQuestionMark, Clock4, MessagesSquare, X, Plus, ChevronDown, ArrowBigUp, ArrowBigDown, Edit2, MoreVertical, Trash2, CheckCircle2 } from "lucide-react";
import Badge from "../../ui/Badge";
import { Button } from "../../ui/Button";
import { Input } from "../../ui/Input";
import { Textarea } from "../../ui/Textarea";
import Discussion from "./Discussion";
import { getInitials, getCurrentUserId } from "@/utils/userUtils";
import { VoteType, VoteTypeEnum, type LocalVoteState } from "@/types/voting";

type DiscussionVoteSnapshot = {
  upvoteCount: number;
  downvoteCount: number;
  userVote: VoteType | null;
};

const calculateVoteChange = (
  upvotes: number,
  downvotes: number,
  currentVote: VoteType | null,
  voteType: VoteType
) => {
  let nextUpvotes = upvotes;
  let nextDownvotes = downvotes;
  let nextVote: VoteType | null = voteType;

  if (currentVote === voteType) {
    nextVote = null;

    if (voteType === VoteTypeEnum.UPVOTE) {
      nextUpvotes = Math.max(0, nextUpvotes - 1);
    } else {
      nextDownvotes = Math.max(0, nextDownvotes - 1);
    }
  } else if (voteType === VoteTypeEnum.UPVOTE) {
    nextUpvotes = nextUpvotes + 1;
    if (currentVote === VoteTypeEnum.DOWNVOTE) {
      nextDownvotes = Math.max(0, nextDownvotes - 1);
    }
  } else {
    nextDownvotes = nextDownvotes + 1;
    if (currentVote === VoteTypeEnum.UPVOTE) {
      nextUpvotes = Math.max(0, nextUpvotes - 1);
    }
  }

  return {
    upvotes: nextUpvotes,
    downvotes: nextDownvotes,
    userVote: nextVote,
  };
};

export interface TopicMeta {
  id: string;
  idForum?: string;
  title: string;
  body?: string;              // Changed from questionDetail to match API
  createdBy: string;          // Changed from startedBy to match API
  createdAt: string;          // Changed from startedAgo to match API
  commentCount?: number;      // Changed from repliesCount to match API
  isResolved?: boolean;       // Changed from state to match API
  resolvedAt?: string | null; // Added from API
  resolvedBy?: string | null; // Added from API
  upvoteCount?: number;       // Added from API
  downvoteCount?: number;     // Added from API
  userVote?: VoteType | null; // User's vote on this topic
  avatarInitials?: string;
  avatarBadge?: number | string;
  // Computed properties for UI
  startedAgo?: string;        // Computed from createdAt
  lastReplyAgo?: string;      // Computed from discussions
  state?: "open" | "closed";  // Computed from isResolved
  repliesCount?: number;      // Computed from discussions length
  // Legacy properties for backward compatibility
  questionDetail?: string;    // Alias for body
  startedBy?: string;         // Alias for createdBy
}

export interface Discussion {
  id: string;
  idTopic?: string;           // Added from API
  idUser: string;             // Changed from author to match API
  idParent?: string;   // Changed from replyingToId to match API
  idRoot?: string;     // Added from API
  comment: string;            // Changed from content to match API
  upvoteCount: number;        // ✅ match API
  downvoteCount: number;      // ✅ match API
  discussionType: 'direct' | 'nestedFirst' | 'nestedSecond'; // ✅ match API
  isUpdated?: boolean;        // Added from API
  createdAt: string;          // Changed from time to match API
  updatedAt?: string;         // Added from API
  // Computed properties for UI
  avatar?: string;
  author?: string;            // Computed from idUser
  time?: string;              // Computed from createdAt
  content?: string;           // Computed from comment
  replyingToId?: string;      // Computed from idParent
  replyingToAuthor?: string;  // Computed from idParent
  userVote?: VoteType | null; // User's vote on this discussion
}

export interface TopicProps {
  meta: TopicMeta;
  discussions?: Discussion[]; // Optional untuk infinite scroll
  currentUserId?: string;
  defaultShowAll?: boolean;
  onSubmitReply?: (payload: {
    topicId: string;
    text: string;
    replyingToDiscussion?: Discussion;
  }) => void;
  onUpvoteReply?: (replyId: string, voteType: VoteType) => Promise<Discussion | void> | Discussion | void;
  onDownvoteReply?: (replyId: string, voteType: VoteType) => Promise<Discussion | void> | Discussion | void;
  onLoadMoreDiscussions?: () => void; // New: callback untuk load more
  onVoteTopic?: (topicId: string, voteType: VoteType) => Promise<void> | void;
  topicVotes?: LocalVoteState;
  isVotingTopic?: boolean;
  isVotingDiscussion?: boolean;
  // New: Topic edit/delete functionality
  canEditTopic?: boolean;
  onEditTopic?: (topicId: string, newTitle: string, newDescription?: string) => void;
  onDeleteTopic?: (topicId: string) => void;
  onResolveTopic?: (topicId: string) => void;
  isResolvingTopic?: boolean;
  // New: Discussion edit/delete functionality
  canEditDiscussion?: boolean;
  onEditDiscussion?: (discussionId: string, newContent: string) => void;
  onDeleteDiscussion?: (discussionId: string) => void;
  editingDiscussionId?: string | null;
  className?: string;
}



/**
 * Topic - Main component untuk menampilkan topik pertanyaan beserta semua diskusi/jawaban
 *
 * Features:
 * - Header dengan pertanyaan utama
 * - Daftar diskusi/jawaban
 * - Voting system
 * - Reply functionality
 * - View more/less discussions
 */
export function Topic({
  meta,
  discussions: initialDiscussions = [],
  currentUserId,
  defaultShowAll,
  onSubmitReply,
  onUpvoteReply,
  onDownvoteReply,
  onLoadMoreDiscussions,
  onVoteTopic,
  topicVotes,
  isVotingTopic = false,
  isVotingDiscussion = false,
  canEditTopic = false,
  onEditTopic,
  onDeleteTopic,
  onResolveTopic,
  isResolvingTopic = false,
  canEditDiscussion = false,
  onEditDiscussion,
  onDeleteDiscussion,
  editingDiscussionId,
  className,
}: TopicProps) {
  const [votingType, setVotingType] = useState<'upvote' | 'downvote' | null>(null);
  const [isSubmittingReply, setIsSubmittingReply] = useState(false);
  const [localTopicVotes, setLocalTopicVotes] = useState<LocalVoteState | undefined>(topicVotes);

  // State untuk prevent multiple rapid clicks
  const [localIsVotingTopic, setLocalIsVotingTopic] = useState(false);
  const votingDiscussionIdsRef = useRef(new Set<string>());

  // Reset voting type when voting is complete
  useEffect(() => {
    if (!localIsVotingTopic) {
      setVotingType(null);
    }
  }, [localIsVotingTopic]);

  const [discussions, setDiscussions] = useState(() => initialDiscussions || []);
  const previousInitialDiscussionsRef = useRef(initialDiscussions);
  const pendingDiscussionVotesRef = useRef(new Map<string, { previous: DiscussionVoteSnapshot; expected: DiscussionVoteSnapshot }>());
  const [pendingDiscussionVersion, setPendingDiscussionVersion] = useState(0);
  const setPendingDiscussionEntry = (
    discussionId: string,
    entry: { previous: DiscussionVoteSnapshot; expected: DiscussionVoteSnapshot }
  ) => {
    pendingDiscussionVotesRef.current.set(discussionId, entry);
    setPendingDiscussionVersion((version) => version + 1);
  };

  const updatePendingDiscussionEntry = (
    discussionId: string,
    updater: (entry: { previous: DiscussionVoteSnapshot; expected: DiscussionVoteSnapshot }) =>
      { previous?: DiscussionVoteSnapshot; expected?: DiscussionVoteSnapshot } | null | undefined
  ) => {
    const currentEntry = pendingDiscussionVotesRef.current.get(discussionId);
    if (!currentEntry) {
      return;
    }

    const updates = updater(currentEntry);
    if (!updates) {
      return;
    }

    const nextEntry = {
      previous: updates.previous ?? currentEntry.previous,
      expected: updates.expected ?? currentEntry.expected,
    };

    pendingDiscussionVotesRef.current.set(discussionId, nextEntry);
    setPendingDiscussionVersion((version) => version + 1);
  };

  const removePendingDiscussionEntry = (discussionId: string) => {
    if (pendingDiscussionVotesRef.current.delete(discussionId)) {
      setPendingDiscussionVersion((version) => version + 1);
    }
  };
  const pendingTopicVoteRef = useRef<{ previous: LocalVoteState; expected: LocalVoteState } | null>(null);

  useEffect(() => {
    pendingTopicVoteRef.current = null;
    if (pendingDiscussionVotesRef.current.size > 0) {
      pendingDiscussionVotesRef.current.clear();
      setPendingDiscussionVersion((version) => version + 1);
    }
  }, [meta.id]);

  useEffect(() => {
    // Simplified state management - langsung gunakan server data
    // React Query optimistic updates akan handle UI updates
    setLocalTopicVotes(topicVotes);
  }, [topicVotes]);

  useEffect(() => {
    if (previousInitialDiscussionsRef.current === initialDiscussions) {
      return;
    }

    previousInitialDiscussionsRef.current = initialDiscussions;

    setDiscussions((currentDiscussions) => {
      const incomingDiscussions = initialDiscussions || [];
      const currentDiscussionMap = new Map(
        currentDiscussions.map((discussion) => [discussion.id, discussion])
      );

      return incomingDiscussions.map((incomingDiscussion) => {
        const currentDiscussion = currentDiscussionMap.get(incomingDiscussion.id);
        const pending = pendingDiscussionVotesRef.current.get(incomingDiscussion.id);

        if (!pending) {
          return {
            ...incomingDiscussion,
            userVote: incomingDiscussion.userVote ?? currentDiscussion?.userVote ?? null,
          };
        }

        const matchesPrevious =
          incomingDiscussion.upvoteCount === pending.previous.upvoteCount &&
          incomingDiscussion.downvoteCount === pending.previous.downvoteCount;

        const matchesExpected =
          incomingDiscussion.upvoteCount === pending.expected.upvoteCount &&
          incomingDiscussion.downvoteCount === pending.expected.downvoteCount;

        if (matchesPrevious) {
          return {
            ...incomingDiscussion,
            upvoteCount: pending.expected.upvoteCount,
            downvoteCount: pending.expected.downvoteCount,
            userVote: pending.expected.userVote ?? currentDiscussion?.userVote ?? null,
          };
        }

        if (matchesExpected) {
          removePendingDiscussionEntry(incomingDiscussion.id);
          return {
            ...incomingDiscussion,
            upvoteCount: pending.expected.upvoteCount,
            downvoteCount: pending.expected.downvoteCount,
            userVote: incomingDiscussion.userVote ?? currentDiscussion?.userVote ?? null,
          };
        }

        return {
          ...incomingDiscussion,
          userVote:
            incomingDiscussion.userVote ??
            pending.expected.userVote ??
            currentDiscussion?.userVote ??
            null,
        };
      });
    });
  }, [initialDiscussions]);
  const [showAllDiscussions, setShowAllDiscussions] = useState(!!defaultShowAll);
  const [showReplyForm, setShowReplyForm] = useState(false);
  const [replyText, setReplyText] = useState("");
  const [replyingTo, setReplyingTo] = useState<{ id: string; author: string } | null>(null);
  const [showTopicMenu, setShowTopicMenu] = useState(false);

  // Topic edit states
  const [isEditingTopic, setIsEditingTopic] = useState(false);
  const [editTitle, setEditTitle] = useState(meta.title);
  const [editDescription, setEditDescription] = useState(meta.questionDetail || "");
  const [isSavingTopic, setIsSavingTopic] = useState(false);

  // Sync topic edit states dengan meta changes
  useEffect(() => {
    setEditTitle(meta.title);
    setEditDescription(meta.questionDetail || "");
  }, [meta.title, meta.questionDetail]);

  const updateDiscussionVoteOptimistically = (discussionId: string, voteType: VoteType) => {
    let previousSnapshot: DiscussionVoteSnapshot | null = null;
    let expectedSnapshot: DiscussionVoteSnapshot | null = null;

    setDiscussions((currentDiscussions) =>
      currentDiscussions.map((discussion) => {
        if (discussion.id !== discussionId) {
          return discussion;
        }

        previousSnapshot = {
          upvoteCount: discussion.upvoteCount || 0,
          downvoteCount: discussion.downvoteCount || 0,
          userVote: discussion.userVote || null,
        };

        const result = calculateVoteChange(
          previousSnapshot.upvoteCount,
          previousSnapshot.downvoteCount,
          previousSnapshot.userVote,
          voteType
        );

        expectedSnapshot = {
          upvoteCount: result.upvotes,
          downvoteCount: result.downvotes,
          userVote: result.userVote,
        };

        return {
          ...discussion,
          upvoteCount: result.upvotes,
          downvoteCount: result.downvotes,
          userVote: result.userVote,
        };
      })
    );

    if (expectedSnapshot && previousSnapshot) {
      setPendingDiscussionEntry(discussionId, {
        previous: previousSnapshot,
        expected: expectedSnapshot,
      });
    }
  };

  const handleDiscussionVote = async (
    discussionId: string,
    voteType: VoteType,
    voteHandler?: (discussionId: string, voteType: VoteType) => Promise<Discussion | void> | Discussion | void
  ) => {
    if (!currentUserId) return;

    // Prevent multiple rapid clicks on same discussion
    if (votingDiscussionIdsRef.current.has(discussionId)) {
      return;
    }

    // Add to voting set
    votingDiscussionIdsRef.current.add(discussionId);

    const previousDiscussions = discussions.map((discussion) => ({ ...discussion }));
    updateDiscussionVoteOptimistically(discussionId, voteType);

    try {
      const result = await voteHandler?.(discussionId, voteType);

      if (result && typeof result === "object" && "id" in result) {
        const discussionResult = result as Discussion;
        const pendingEntry = pendingDiscussionVotesRef.current.get(discussionId);
        let skipServerResult = false;
        let matchesExpectedResponse = false;
        let nextExpectedSnapshot: DiscussionVoteSnapshot | null = null;

        setDiscussions((currentDiscussions) =>
          currentDiscussions.map((discussion) => {
            if (discussion.id !== discussionResult.id) {
              return discussion;
            }

            const responseUpvotes =
              typeof discussionResult.upvoteCount !== "undefined"
                ? discussionResult.upvoteCount
                : discussion.upvoteCount;
            const responseDownvotes =
              typeof discussionResult.downvoteCount !== "undefined"
                ? discussionResult.downvoteCount
                : discussion.downvoteCount;
            const responseUserVote =
              typeof discussionResult.userVote !== "undefined"
                ? discussionResult.userVote
                : discussion.userVote ?? null;

            if (pendingEntry) {
              const matchesPrevious =
                responseUpvotes === pendingEntry.previous.upvoteCount &&
                responseDownvotes === pendingEntry.previous.downvoteCount;

              matchesExpectedResponse =
                responseUpvotes === pendingEntry.expected.upvoteCount &&
                responseDownvotes === pendingEntry.expected.downvoteCount;

              if (matchesPrevious) {
                skipServerResult = true;
                return discussion;
              }

              if (!matchesExpectedResponse) {
                nextExpectedSnapshot = {
                  upvoteCount: responseUpvotes,
                  downvoteCount: responseDownvotes,
                  userVote: responseUserVote,
                };
              }
            }

            return {
              ...discussion,
              upvoteCount: responseUpvotes,
              downvoteCount: responseDownvotes,
              userVote: responseUserVote,
            };
          })
        );

        if (pendingEntry) {
          if (skipServerResult) {
            // Keep optimistic snapshot; server still returning stale data
          } else if (matchesExpectedResponse) {
            removePendingDiscussionEntry(discussionId);
          } else if (nextExpectedSnapshot) {
            setPendingDiscussionEntry(discussionId, {
              previous: pendingEntry.previous,
              expected: nextExpectedSnapshot,
            });
          }
        }
      }
    } catch (error) {
      console.error("Failed to update discussion vote:", error);
      setDiscussions(previousDiscussions);
      removePendingDiscussionEntry(discussionId);
    } finally {
      // Remove from voting set to allow voting again
      votingDiscussionIdsRef.current.delete(discussionId);
    }
  };

  // Vote handlers
  const handleUpvote = (discussionId: string) => {
    void handleDiscussionVote(discussionId, VoteTypeEnum.UPVOTE, onUpvoteReply);
  };

  const handleDownvote = (discussionId: string) => {
    void handleDiscussionVote(discussionId, VoteTypeEnum.DOWNVOTE, onDownvoteReply);
  };

  // Reply form handlers
  const handleSubmitReply = async () => {
    const text = replyText.trim();
    if (!text) return;

    setIsSubmittingReply(true);
    try {
      await onSubmitReply?.({
        topicId: meta.id,
        text,
        replyingToDiscussion: replyingTo ? discussions.find(d => d.id === replyingTo.id) : undefined,
      });

      // Reset form hanya jika berhasil
      setReplyText("");
      setShowReplyForm(false);
      setReplyingTo(null);
    } catch (error) {
      console.error("Failed to submit reply:", error);
      // Form tidak di-reset jika gagal, user bisa mencoba lagi
    } finally {
      setIsSubmittingReply(false);
    }
  };

  const handleStartReply = (discussion: Discussion) => {
    setReplyingTo({ id: discussion.id, author: discussion.author || getCurrentUserId() });
    setShowReplyForm(true);
  };

  const handleCancelReply = () => {
    setReplyText("");
    setShowReplyForm(false);
    setReplyingTo(null);
  };

  // Topic edit/delete handlers
  const handleEditTopic = () => {
    setShowTopicMenu(false);
    setIsEditingTopic(true);
    setEditTitle(meta.title);
    setEditDescription(meta.questionDetail || "");
  };

  const handleSaveTopicEdit = async () => {
    const trimmedTitle = editTitle.trim();
    const trimmedDescription = editDescription.trim();

    if (!trimmedTitle || trimmedTitle === meta.title) {
      setIsEditingTopic(false);
      setEditTitle(meta.title);
      setEditDescription(meta.questionDetail || "");
      return;
    }

    setIsSavingTopic(true);
    try {
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 500));

      // Call parent handler with updated data
      onEditTopic?.(meta.id, trimmedTitle, trimmedDescription || undefined);

      // Reset editing state
      setIsEditingTopic(false);
      setShowTopicMenu(false);
    } catch (error) {
      console.error('Failed to update topic:', error);
      // Could show error toast here
    } finally {
      setIsSavingTopic(false);
    }
  };

  const handleCancelTopicEdit = () => {
    setIsEditingTopic(false);
    setEditTitle(meta.title);
    setEditDescription(meta.questionDetail || "");
  };

  const handleDeleteTopic = () => {
    setShowTopicMenu(false);
    if (confirm('Apakah Anda yakin ingin menghapus topic ini?')) {
      onDeleteTopic?.(meta.id);
    }
  };

  const handleResolveTopic = () => {
    setShowTopicMenu(false);
    if (meta.state === "closed" || isResolvingTopic) {
      return;
    }
    onResolveTopic?.(meta.id);
  };

  const getOptimisticTopicVote = (currentVotes: LocalVoteState, voteType: VoteType): LocalVoteState => {
    const result = calculateVoteChange(
      currentVotes.upvotes || 0,
      currentVotes.downvotes || 0,
      currentVotes.userVote ?? null,
      voteType
    );

    return {
      upvotes: result.upvotes,
      downvotes: result.downvotes,
      userVote: result.userVote,
    };
  };

  const handleTopicVote = async (voteType: VoteType) => {
    if (!localTopicVotes || localIsVotingTopic) return;

    // Prevent multiple rapid clicks
    setLocalIsVotingTopic(true);

    try {
      await onVoteTopic?.(meta.id, voteType);
    } catch (error) {
      console.error("Failed to update topic vote:", error);
    } finally {
      setLocalIsVotingTopic(false);
    }
  };

  // Discussion edit handler - update local state
  const handleEditDiscussion = (discussionId: string, newContent: string) => {
    setDiscussions((currentDiscussions) => {
      const updatedDiscussions = currentDiscussions.map((discussion) => {
        if (discussion.id !== discussionId) return discussion;
        return { ...discussion, content: newContent };
      });
      return updatedDiscussions;
    });

    // Call parent handler if provided
    onEditDiscussion?.(discussionId, newContent);
  };

  // Discussion delete handler - remove from local state
  const handleDeleteDiscussion = (discussionId: string) => {
    setDiscussions((currentDiscussions) => {
      const updatedDiscussions = currentDiscussions.filter(
        (discussion) => discussion.id !== discussionId
      );
      return updatedDiscussions;
    });

    // Call parent handler if provided
    onDeleteDiscussion?.(discussionId);
  };

  // Discussion visibility
  const displayedDiscussions = useMemo(() => {
    const baseDiscussions = showAllDiscussions ? discussions : discussions.slice(0, 2);

    return baseDiscussions.map((discussion) => {
      const pending = pendingDiscussionVotesRef.current.get(discussion.id);
      if (!pending) {
        return discussion;
      }

      return {
        ...discussion,
        upvoteCount: pending.expected.upvoteCount,
        downvoteCount: pending.expected.downvoteCount,
        userVote: pending.expected.userVote ?? discussion.userVote ?? null,
      };
    });
  }, [discussions, showAllDiscussions, pendingDiscussionVersion]);
  const hasMoreDiscussions = discussions.length > 2;

  return (
    <section
      className={[
        "w-full bg-[var(--surface,white)]",
        "rounded-[var(--radius-xl,16px)]",
        ...(className ? [className] : []),
      ]
        .filter(Boolean)
        .join(" ")}
      aria-labelledby={`topic-${meta.id}`}
    >
      {/* Topic Header */}
      <header id={`topic-${meta.id}`} className="relative px-6 pt-6 pb-4 h-full">
        {/* Top Actions */}
        <div className="absolute right-6 top-6 z-10 flex items-center gap-2">
          {/* Status Badge */}
          <Badge
            size="sm"
            variant={meta.state === "open" ? "default" : "outline"}
            className={`${
              meta.state === "open"
                ? "bg-green-500 text-white border-green-500 shadow-sm"
                : "bg-gray-100 text-gray-700 border-gray-300"
            }`}
          >
            {meta.state === "open" ? "Open" : "Closed"}
          </Badge>

          {/* Topic Menu */}
          {canEditTopic && (
            <div className="relative">
              <Button
                variant="ghost"
                className="w-11 h-11 p-0 text-gray-600 hover:text-gray-800 hover:bg-gray-100 flex items-center justify-center"
                onClick={() => setShowTopicMenu(!showTopicMenu)}
                aria-label="Menu topik"
              >
                <MoreVertical className="w-5 h-5" />
              </Button>

              {/* Dropdown Menu */}
              {showTopicMenu && (
                <>
                  {/* Backdrop */}
                  <div
                    className="fixed inset-0 z-10"
                    onClick={() => setShowTopicMenu(false)}
                  />

                  {/* Menu */}
                  <div className="absolute right-0 top-12 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-20">
                    <button
                      onClick={handleResolveTopic}
                      disabled={meta.state === "closed" || isResolvingTopic}
                      className={`w-full flex items-center gap-3 px-4 py-2 text-sm transition-colors ${
                        meta.state === "closed" || isResolvingTopic
                          ? "text-gray-400 cursor-not-allowed"
                          : "text-gray-700 hover:bg-gray-50"
                      }`}
                    >
                      <CheckCircle2 className={`w-4 h-4 ${meta.state === "closed" || isResolvingTopic ? "text-gray-400" : "text-gray-600"}`} />
                      {meta.state === "closed" ? "Sudah Selesai" : isResolvingTopic ? "Menandai..." : "Tandai Selesai"}
                    </button>
                    <button
                      onClick={handleEditTopic}
                      className="w-full flex items-center gap-3 px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
                    >
                      <Edit2 className="w-4 h-4 text-gray-600" />
                      Edit Topic
                    </button>
                    <button
                      onClick={handleDeleteTopic}
                      className="w-full flex items-center gap-3 px-4 py-2 text-sm text-red-600 hover:bg-red-50 transition-colors"
                    >
                      <Trash2 className="w-4 h-4 text-red-500" />
                      Hapus Topic
                    </button>
                  </div>
                </>
              )}
            </div>
          )}
        </div>

        {/* Main Content */}
        <div className="flex items-start gap-4">
          {/* Avatar Section */}
          <div className="relative shrink-0">
            <div
              className="size-12 rounded-[var(--radius-lg,12px)] bg-[color-mix(in_oklab,var(--color-primary,#2563eb)_85%,white_15%)] text-white flex items-center justify-center shadow-sm"
              aria-label={`${meta.startedBy} avatar`}
            >
              <span
                className="text-[var(--font-sm,0.875rem)] font-[var(--font-body-bold,600)] tracking-wide"
                role="img"
              >
                {(meta.avatarInitials && meta.avatarInitials.trim().toUpperCase()) || getInitials(meta.startedBy || meta.createdBy || '')}
              </span>
            </div>

            {/* Avatar Badge */}
            {meta.avatarBadge != null && (
              <CircleQuestionMark
                className="size-5 bg-[var(--success)] text-white rounded-full absolute -bottom-1.5 -right-1.5"
                aria-label="Question badge"
              />
            )}

            {/* Voting Section */}
            {localTopicVotes && (
              <div className="flex flex-col items-center gap-1 mt-3">
                {/* Upvote Button */}
                <button
                  type="button"
                  onClick={() => handleTopicVote(VoteTypeEnum.UPVOTE)}
                  disabled={localIsVotingTopic}
                  className={`vote-button vote-container ${localIsVotingTopic ? 'vote-loading' : ''} ${
                    localTopicVotes.userVote === VoteTypeEnum.UPVOTE
                      ? 'text-[var(--success)] vote-active'
                      : 'text-[var(--color-foreground-muted)] hover:text-[var(--success)] vote-active'
                  } ${localIsVotingTopic ? 'opacity-50 cursor-not-allowed' : ''}`}
                  aria-label={`Upvote topic, ${localTopicVotes.upvotes} upvotes`}
                >
                  {localIsVotingTopic && votingType === 'upvote' ? (
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-300 border-t-green-500"></div>
                  ) : (
                    <ArrowBigUp className={`size-4 ${localTopicVotes.userVote === VoteTypeEnum.UPVOTE ? 'fill-current' : ''}`} />
                  )}
                </button>

                {/* Vote Count */}
                <div className="text-center">
                  <span className={`vote-count text-xs font-medium ${
                    localTopicVotes.userVote === VoteTypeEnum.UPVOTE
                      ? 'text-[var(--success,#16a34a)]'
                      : localTopicVotes.userVote === VoteTypeEnum.DOWNVOTE
                      ? 'text-[var(--color-error,#dc2626)]'
                      : 'text-[var(--color-foreground,#6b7280)]'
                  }`}>
                    {Math.max(0, (localTopicVotes.upvotes || 0) - (localTopicVotes.downvotes || 0))}
                  </span>
                </div>

                {/* Downvote Button */}
                <button
                  type="button"
                  onClick={() => handleTopicVote(VoteTypeEnum.DOWNVOTE)}
                  disabled={localIsVotingTopic}
                  className={`vote-button vote-container ${localIsVotingTopic ? 'vote-loading' : ''} ${
                    localTopicVotes.userVote === VoteTypeEnum.DOWNVOTE
                      ? 'bg-[var(--color-error,#dc2626)] text-white shadow-sm vote-active'
                      : 'bg-[var(--color-gray-100,#f3f4f6)] text-[var(--color-foreground-muted,#6b7280)] hover:text-[var(--color-error,#dc2626)] hover:bg-[var(--color-error,#dc2626)/10] vote-active'
                  } ${localIsVotingTopic ? 'opacity-50 cursor-not-allowed' : ''}`}
                  aria-label={`Downvote topic, ${localTopicVotes.downvotes} downvotes`}
                >
                  {localIsVotingTopic && votingType === 'downvote' ? (
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-300 border-t-red-500"></div>
                  ) : (
                    <ArrowBigDown className="size-4" />
                  )}
                </button>
              </div>
            )}
          </div>

          {/* Content Section */}
          <div className="flex-1 min-w-0 flex flex-col h-full">
            {/* Title and Description */}
            <div className="flex-1">
              {isEditingTopic ? (
                // Edit Mode - Input fields for title and description
                <div className="space-y-3">
                  {/* Title Input */}
                  <Input
                    placeholder="Edit judul topic..."
                    value={editTitle}
                    onChange={(e) => setEditTitle(e.target.value)}
                    className="text-md font-bold"
                    autoFocus
                    disabled={isSavingTopic}
                  />

                  {/* Description Textarea */}
                  <Textarea
                    placeholder="Edit deskripsi topic..."
                    value={editDescription}
                    onChange={(e) => setEditDescription(e.target.value)}
                    rows={3}
                    className="text-sm resize-none"
                    disabled={isSavingTopic}
                  />

                  {/* Action Buttons */}
                  <div className="flex justify-end gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleCancelTopicEdit}
                      disabled={isSavingTopic}
                    >
                      Batal
                    </Button>
                    <Button
                      size="sm"
                      onClick={handleSaveTopicEdit}
                      disabled={!editTitle.trim() || editTitle.trim() === meta.title || isSavingTopic}
                      isLoading={isSavingTopic}
                    >
                      {isSavingTopic ? "Menyimpan..." : "Simpan"}
                    </Button>
                  </div>
                </div>
              ) : (
                // Display Mode - Static title and description
                <>
                  {/* Title - Fixed */}
                  <h3 className="text-[var(--color-foreground,#111827)] text-md font-bold mb-3 line-clamp-2">
                    {meta.title}
                  </h3>

                  
                  {/* Question Detail - Dynamic Height */}
                  {meta.questionDetail && (
                    <p className="text-md text-[var(--color-foreground-muted)] leading-relaxed min-h-[52px]">
                      {meta.questionDetail}
                    </p>
                  )}
                </>
              )}
            </div>

            {/* Metadata and Stats Container - Always at Bottom */}
            <div className="mt-auto pt-3 space-y-3">
              {/* Metadata Section */}
              <div className="text-sm text-gray-600">
                <span>Dibuat oleh </span>
                <span className="text-[var(--color-foreground,#111827)] font-semibold">
                  {meta.startedBy}
                </span>
                <span className="mx-1.5">•</span>
                <span>{meta.startedAgo}</span>
              </div>

              {/* Stats Chips */}
              <div className="flex items-center gap-3 flex-wrap">
                {/* Replies Count */}
                <span className="inline-flex items-center gap-1.5 text-[var(--success,#16a34a)] text-[12px]">
                  <span
                    className="inline-flex items-center justify-center size-6 rounded-md bg-[color-mix(in_oklab,white_90%,var(--success,#16a34a))]"
                    aria-label="Replies count"
                  >
                    <MessagesSquare className="size-3.5" />
                  </span>
                  <p className="text-[var(--color-foreground-muted,#6b7280)] font-medium">
                    {meta.repliesCount} {meta.repliesCount === 1 ? "balasan" : "balasan"}
                  </p>
                </span>

                {/* Last Reply */}
                <span className="inline-flex items-center gap-1.5 text-[var(--color-primary,#2563eb)] text-[12px]">
                  <span
                    className="inline-flex items-center justify-center size-6 rounded-md bg-[var(--color-primary-50,rgba(37,99,235,0.08))]"
                    aria-label="Last reply time"
                  >
                    <Clock4 className="size-3.5" />
                  </span>
                  <p className="text-[var(--color-foreground-muted,#6b7280)] font-medium">
                    Terakhir {meta.lastReplyAgo}
                  </p>
                </span>
              </div>
            </div>
          </div>
        </div>
      </header>

      {/* Discussions Section */}
      {discussions.length > 0 && (
        <div className="border-t border-[var(--border,rgba(0,0,0,0.08))]">
            <ul className="flex flex-col" role="list" aria-label="Daftar balasan">
              {displayedDiscussions.map((discussion) => (
                <li key={discussion.id} className="px-4 py-4 first:pt-6 last:pb-6" role="listitem">
                  <Discussion
                    discussion={discussion}
                    discussionType={discussion.discussionType}
                    onUpvote={() => handleUpvote(discussion.id)}
                    onDownvote={() => handleDownvote(discussion.id)}
                    onStartReply={() => handleStartReply(discussion)}
                    currentUserId={currentUserId}
                    userVote={discussion.userVote}
                    isVoting={votingDiscussionIdsRef.current.has(discussion.id)}
                    canEditDiscussion={canEditDiscussion}
                    onEditDiscussion={handleEditDiscussion}
                    onDeleteDiscussion={handleDeleteDiscussion}
                    isEditingDiscussion={editingDiscussionId === discussion.id}
                  />
                </li>
              ))}
            </ul>

            {/* View More/Less Button */}
            {hasMoreDiscussions && (
              <div className="px-4 pb-3">
                <button
                  type="button"
                  onClick={() => setShowAllDiscussions((v) => !v)}
                  className="inline-flex items-center gap-2 text-[var(--color-primary,#2563eb)] text-[var(--font-sm,0.875rem)] font-[var(--font-body-bold,600)] focus:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-focus-ring,#2563eb)] focus-visible:ring-offset-2"
                  aria-expanded={showAllDiscussions}
                  aria-controls={`discussions-${meta.id}`}
                >
                  <span className="text-xs">
                    {showAllDiscussions
                      ? `Sembunyikan ${discussions.length - 2} ${discussions.length - 2 === 1 ? "balasan" : "balasan"}`
                      : `Lihat ${discussions.length - 2} ${discussions.length - 2 === 1 ? "balasan lagi" : "balasan lagi"}`
                    }
                  </span>
                  <ChevronDown
                    className={`size-3.5 transition-transform ${showAllDiscussions ? "rotate-180" : ""}`}
                  />
                </button>
              </div>
            )}
        </div>
      )}

      {/* Reply Form Section */}
      <div className="border-t border-[var(--border,rgba(0,0,0,0.08))] px-4 py-3">
        {!showReplyForm ? (
          <button
            type="button"
            onClick={() => setShowReplyForm(true)}
            className="inline-flex items-center gap-1.5 text-sm font-[var(--font-body-bold,600)] text-[var(--success)] focus:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-focus-ring)] focus-visible:ring-offset-2"
            aria-label="Buat balasan baru"
          >
            <Plus className="size-4.5" />
            Balas Diskusi
          </button>
        ) : (
          <div className="space-y-3" id={`discussions-${meta.id}`}>
            {/* Replying To Indicator */}
            {replyingTo && (
              <div className="flex items-center gap-2 text-xs text-[var(--color-foreground-muted)]">
                <span>Membalas kepada <strong>@{replyingTo.author}</strong></span>
                <button
                  onClick={() => setReplyingTo(null)}
                  className="p-1 rounded-full hover:bg-[var(--color-primary-50)]"
                  aria-label="Batalkan balasan ke pengguna ini"
                >
                  <X className="size-3" />
                </button>
              </div>
            )}

            {/* Reply Form */}
            <div className="flex gap-3">
              {/* Current User Avatar */}
              <div
                className="shrink-0 size-9 rounded-full bg-[color-mix(in_oklab,white_10%,var(--color-primary,#2563eb))] text-[var(--color-on-primary,#ffffff)] flex items-center justify-center shadow-sm"
                aria-label="Avatar Anda"
              >
                <span className="text-[var(--font-2xs,0.6875rem)] font-[var(--font-body-bold,600)]">
                  Me
                </span>
              </div>

              {/* Input Area */}
              <div className="flex-1">
                <Textarea
                  placeholder="Tulis balasan Anda..."
                  value={replyText}
                  onChange={(e) => setReplyText(e.target.value)}
                  rows={3}
                  className="text-sm"
                  aria-label="Isi balasan"
                />
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex justify-end gap-2 pl-12">
              <Button
                variant="outline"
                size="sm"
                onClick={handleCancelReply}
              >
                Batal
              </Button>
              <Button
                size="sm"
                onClick={handleSubmitReply}
                disabled={!replyText.trim() || isSubmittingReply}
                isLoading={isSubmittingReply}
              >
                {isSubmittingReply ? "Mengirim..." : "Kirim Balasan"}
              </Button>
            </div>
          </div>
        )}
      </div>
    </section>
  );
}


// Default export untuk memudahkan import
export default Topic;
